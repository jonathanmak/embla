\section{Overview of the Implementation of Embla}

In order to understand dependency profiling with Embla, we 
here give an overview of the implementation of Embla. 

Embla is based on instrumented execution of binary code. Although
our examples of profiling output use a high level language (C),
the profiling itself is on instruction level, followed by 
mapping the information to source level using debugging information 
in the standard way.

Embla uses the Valgrind instrumentation infrastructure, so there
is no offline code rewriting; the Embla tool behaves like an emulator
of the hardware.

There are three fundamental data structures in Embla.
\begin{description}
\item[The memory table:]
Contains information about the most recent reads and writes to each
block of memory. Blocksize is a tradeoff between memory use and 
precision. 
\item[The activation tree:]
Contains a record for each stack frame allocated during execution. 
The rightmost branch of the activation tree corresponds to the stack.
\item[The result table:]
A hash table mapping dependency signatures to counters of RAW, WAR 
and WAR dependencies. Dependency signatures identify the source and
target of the dependency as well as other information of interest.
\end{description}
