\section{The Tool}

Embla helps the user find dependencies in a program. Technically, a
dependece is two references, not both reads, to overlapping memory
locations with no interveaning write. What makes Embla special is the
way dependencies are reported. Since the idea is to support manual,
function call level parallelization, we are not really interested in
knowing that a memory read on line 11754 in function {\tt foo}
sometimes reads a value last written in line 3411 in function {\tt
bar}. Rather, the user is concerned with a completely different
function {\tt baz} and would like to know whether the call to {\tt
foobar} on line 2355 can be made in parallel with the call to {\tt
barfoo} on line 2356.



\subsection{Types of dependencies}

Another dimension that Embla recognizes is where in memory the
location associated with the dependency is situated. In particular, we
want to catch the cases where anti and output dependencies are created
by reuse of memory for new stack frames. This happens when the stack 
shrinks and
then grows again; the new stack frames use the same memory locations,
but only for memory management reasons. With this in mind we have the
following categories:
\begin{description}
\item[s(tack):]
The location has been a part of the stack from the first reference to
the second (inclusive).
\item[f(alse):]
The location was part of the stack when the first reference was made,
then the stack shrunk enough that the location was not part of the
stack and then it became part of the stack again.
\item[o(ther):]
The location has never been part of the stack.
\end{description}

We also categorize dependencies according to properties of the two 
memory references making up the source and target of the dependence. 
This is both in order to give more precise information and to flag
additional dependencies as spurious. 

Dependency endpoints correspond to instruction execution events and
are reported as line numbers with one of the following codes:
\begin{description}
\item[$\epsilon$:] 
No code at all represents an instruction that is
generated from the source code at the indicated line. Thus the 
instruction is part of the function or procedure containing the 
line.
\item[c:]
The instruction was executed by a function (procedure) that was 
(transitively) invoked by a function (procedure) call at the indicated 
line.
\item[h:]
Like {\bf c}, but the function containing the instruction was 
{\em hidden}, that is, it was on a blacklist of functions which, 
like {\tt malloc}, would not give rise to dependencies in the 
parallelized program.
\end{description}


\begin{figure} 
\small
\input{ex1.deplist}
\end{figure}

\begin{figure} 
\small
\input{ex4.deplist}
\end{figure}

\begin{figure} 
\small
\input{ex1.depgraph}
\end{figure}

\begin{figure} 
\small
\input{ex4.depgraph}
\end{figure}

\begin{figure} 
\small
\input{ex5.deplist}
\end{figure}

\begin{figure} 
\small
\input{ex5.depgraph}
\end{figure}


\begin{figure*} 
\small
\input{ex6.deplist}
\end{figure*}

\begin{figure} 
\small
\input{ex6.depgraph}
\end{figure}

